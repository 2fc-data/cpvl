{"ast":null,"code":"var _s = $RefreshSig$();\n// import { useEffect, useRef, useState, useCallback } from 'react';\n// import { useLocalStorage } from 'usehooks-ts';\n// import { getHeaderOptions } from '../services';\n// import { useNavigate } from 'react-router-dom';\n\n// interface IProps {\n//   method?: 'POST' | 'GET' | 'PATCH' | 'PUT' | 'DELETE';\n//   url?: string;\n//   body?: any;\n//   options?: RequestInit;\n// }\n\n// interface FetchError extends Error {\n//   status?: number;\n//   response?: any;\n// }\n\n// const useFetch = <T>({ method = 'GET', url, body, options }: IProps) => {\n//   const [loading, setLoading] = useState(false);\n//   const [data, setData] = useState<T | null>(null);\n//   const [error, setError] = useState<FetchError | null>(null);\n\n//   const [, setIsLogged] = useLocalStorage(\n//     process.env.REACT_APP_LOGGED_KEY || 'APP_LOGGED',\n//     false\n//   );\n//   const navigate = useNavigate();\n//   const abortController = useRef<AbortController | null>(null);\n\n//   const doFetch = useCallback(\n//     async ({\n//       url: fetchUrl,\n//       body: fetchBody,\n//       method: fetchMethod = method\n//     }: {\n//       url: string;\n//       body?: any;\n//       method?: 'POST' | 'GET' | 'PATCH' | 'PUT' | 'DELETE';\n//     }) => {\n//       setLoading(true);\n//       setError(null);\n\n//       // cancela requisição anterior se ainda estiver ativa\n//       if (abortController.current) {\n//         abortController.current.abort();\n//       }\n//       abortController.current = new AbortController();\n\n//       try {\n//         const response = await fetch(fetchUrl, {\n//           method: fetchMethod,\n//           ...(fetchBody && { body: JSON.stringify(fetchBody) }),\n//           ...getHeaderOptions(),\n//           ...options,\n//           signal: abortController.current.signal\n//         });        \n\n//         if (!response.ok) {\n//           const fetchError: FetchError = new Error(\n//             response.statusText || 'Erro na requisição'\n//           );\n//           fetchError.status = response.status;\n//           throw fetchError;\n//         }\n\n//         const json = await response.json();\n\n//         // normaliza resposta no formato `{ data: ... }`\n//         const normalized = json!.data || json;\n\n//         setData(normalized);\n//         return normalized as T;\n//       } catch (err: any) {\n//         if (err.name !== 'AbortError') {\n//           setError(err);\n\n//           if (err.status === 401) {\n//             setIsLogged(false);\n//           }\n//           if (err.status === 403) {\n//             navigate('/');\n//           }\n//         }\n//       } finally {\n//         setLoading(false);\n//       }\n//     },\n//     [method, navigate, options, setIsLogged]\n//   );\n\n//   // efeito inicial caso `url` seja passado direto\n//   useEffect(() => {\n//     if (url) {\n//       doFetch({ url, body, method });\n//     }\n//     return () => {\n//       if (abortController.current) {\n//         abortController.current.abort();\n//       }\n//     };\n//     // eslint-disable-next-line react-hooks/exhaustive-deps\n//   }, [url, body, method]);\n\n//   return { doFetch, data, error, loading };\n// };\n\n// export default useFetch;\n\n// useFetch.tsx (versão atualizada)\nimport { useEffect, useRef, useState, useCallback } from 'react';\nimport { useLocalStorage } from 'usehooks-ts';\nimport { getHeaderOptions } from '../services';\nimport { useNavigate } from 'react-router-dom';\nconst useFetch = _ref => {\n  _s();\n  let {\n    method = 'GET',\n    url,\n    body,\n    options\n  } = _ref;\n  const [loading, setLoading] = useState(false);\n  const [data, setData] = useState(null);\n  const [error, setError] = useState(null);\n  const [, setIsLogged] = useLocalStorage(process.env.REACT_APP_LOGGED_KEY || 'APP_LOGGED', false);\n  const navigate = useNavigate();\n  const abortController = useRef(null);\n  const doFetch = useCallback(async _ref2 => {\n    let {\n      url: fetchUrl,\n      body: fetchBody,\n      method: fetchMethod = method\n    } = _ref2;\n    setLoading(true);\n    setError(null);\n\n    // cancela requisição anterior se ainda estiver ativa\n    if (abortController.current) {\n      abortController.current.abort();\n    }\n    abortController.current = new AbortController();\n\n    // Headers do serviço (ex: Authorization)\n    const baseOptions = getHeaderOptions() || {};\n\n    // Garantir merge correto de headers (não sobrescrever acidentalmente)\n    const mergedHeaders = {\n      ...baseOptions.headers,\n      ...(options && options.headers)\n    };\n\n    // Montar fetch options\n    const fetchOptions = {\n      method: fetchMethod,\n      headers: mergedHeaders,\n      signal: abortController.current.signal,\n      // permite controlar envio de cookies, útil se backend usa sessão\n      credentials: options && options.credentials || baseOptions.credentials || 'same-origin',\n      ...options\n    };\n    if (fetchBody) {\n      // se não existir Content-Type, definir application/json\n      if (!('Content-Type' in (fetchOptions.headers || {}))) {\n        fetchOptions.headers = {\n          ...fetchOptions.headers,\n          'Content-Type': 'application/json'\n        };\n      }\n      fetchOptions.body = JSON.stringify(fetchBody);\n    }\n\n    // DEBUG: inspecionar URL e headers no console\n    // Remover/condicionar em produção\n    // eslint-disable-next-line no-console\n    // console.log('doFetch ->', fetchUrl, fetchOptions);\n\n    try {\n      const response = await fetch(fetchUrl, fetchOptions);\n      const text = await response.text();\n      // Tentar parsear JSON se houver conteúdo\n      let parsed;\n      try {\n        parsed = text ? JSON.parse(text) : null;\n      } catch {\n        parsed = text;\n      }\n      if (!response.ok) {\n        const fetchError = new Error(parsed && parsed.message || response.statusText || 'Erro na requisição');\n        fetchError.status = response.status;\n        fetchError.response = parsed;\n        throw fetchError;\n      }\n\n      // normaliza resposta no formato `{ data: ... }`\n      const normalized = parsed && (parsed.data || parsed);\n      setData(normalized);\n      return normalized;\n    } catch (err) {\n      if (err.name !== 'AbortError') {\n        setError(err);\n\n        // ações automáticas de acordo com status\n        if (err.status === 401) {\n          setIsLogged(false);\n        }\n        if (err.status === 403) {\n          navigate('/');\n        }\n      }\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [method, navigate, options, setIsLogged]);\n\n  // efeito inicial caso `url` seja passado direto\n  useEffect(() => {\n    if (url) {\n      doFetch({\n        url,\n        body,\n        method\n      });\n    }\n    return () => {\n      if (abortController.current) {\n        abortController.current.abort();\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [url, JSON.stringify(body), method]);\n  return {\n    doFetch,\n    data,\n    error,\n    loading\n  };\n};\n_s(useFetch, \"XkAXn6WObBJZ/sPcCJcRyGnb7rE=\", false, function () {\n  return [useLocalStorage, useNavigate];\n});\nexport default useFetch;","map":{"version":3,"names":["useEffect","useRef","useState","useCallback","useLocalStorage","getHeaderOptions","useNavigate","useFetch","_ref","_s","method","url","body","options","loading","setLoading","data","setData","error","setError","setIsLogged","process","env","REACT_APP_LOGGED_KEY","navigate","abortController","doFetch","_ref2","fetchUrl","fetchBody","fetchMethod","current","abort","AbortController","baseOptions","mergedHeaders","headers","fetchOptions","signal","credentials","JSON","stringify","response","fetch","text","parsed","parse","ok","fetchError","Error","message","statusText","status","normalized","err","name"],"sources":["/home/fernando/Documents/develop/www/cpvl/v4_cpvl_2025/cpvl-spa/src/hooks/useFetch.ts"],"sourcesContent":["// import { useEffect, useRef, useState, useCallback } from 'react';\n// import { useLocalStorage } from 'usehooks-ts';\n// import { getHeaderOptions } from '../services';\n// import { useNavigate } from 'react-router-dom';\n\n// interface IProps {\n//   method?: 'POST' | 'GET' | 'PATCH' | 'PUT' | 'DELETE';\n//   url?: string;\n//   body?: any;\n//   options?: RequestInit;\n// }\n\n// interface FetchError extends Error {\n//   status?: number;\n//   response?: any;\n// }\n\n// const useFetch = <T>({ method = 'GET', url, body, options }: IProps) => {\n//   const [loading, setLoading] = useState(false);\n//   const [data, setData] = useState<T | null>(null);\n//   const [error, setError] = useState<FetchError | null>(null);\n\n//   const [, setIsLogged] = useLocalStorage(\n//     process.env.REACT_APP_LOGGED_KEY || 'APP_LOGGED',\n//     false\n//   );\n//   const navigate = useNavigate();\n//   const abortController = useRef<AbortController | null>(null);\n\n//   const doFetch = useCallback(\n//     async ({\n//       url: fetchUrl,\n//       body: fetchBody,\n//       method: fetchMethod = method\n//     }: {\n//       url: string;\n//       body?: any;\n//       method?: 'POST' | 'GET' | 'PATCH' | 'PUT' | 'DELETE';\n//     }) => {\n//       setLoading(true);\n//       setError(null);\n\n//       // cancela requisição anterior se ainda estiver ativa\n//       if (abortController.current) {\n//         abortController.current.abort();\n//       }\n//       abortController.current = new AbortController();\n\n//       try {\n//         const response = await fetch(fetchUrl, {\n//           method: fetchMethod,\n//           ...(fetchBody && { body: JSON.stringify(fetchBody) }),\n//           ...getHeaderOptions(),\n//           ...options,\n//           signal: abortController.current.signal\n//         });        \n\n//         if (!response.ok) {\n//           const fetchError: FetchError = new Error(\n//             response.statusText || 'Erro na requisição'\n//           );\n//           fetchError.status = response.status;\n//           throw fetchError;\n//         }\n\n//         const json = await response.json();\n\n//         // normaliza resposta no formato `{ data: ... }`\n//         const normalized = json!.data || json;\n\n//         setData(normalized);\n//         return normalized as T;\n//       } catch (err: any) {\n//         if (err.name !== 'AbortError') {\n//           setError(err);\n\n//           if (err.status === 401) {\n//             setIsLogged(false);\n//           }\n//           if (err.status === 403) {\n//             navigate('/');\n//           }\n//         }\n//       } finally {\n//         setLoading(false);\n//       }\n//     },\n//     [method, navigate, options, setIsLogged]\n//   );\n\n//   // efeito inicial caso `url` seja passado direto\n//   useEffect(() => {\n//     if (url) {\n//       doFetch({ url, body, method });\n//     }\n//     return () => {\n//       if (abortController.current) {\n//         abortController.current.abort();\n//       }\n//     };\n//     // eslint-disable-next-line react-hooks/exhaustive-deps\n//   }, [url, body, method]);\n\n//   return { doFetch, data, error, loading };\n// };\n\n// export default useFetch;\n\n\n\n\n\n\n// useFetch.tsx (versão atualizada)\nimport { useEffect, useRef, useState, useCallback } from 'react';\nimport { useLocalStorage } from 'usehooks-ts';\nimport { getHeaderOptions } from '../services';\nimport { useNavigate } from 'react-router-dom';\n\ninterface IProps {\n  method?: 'POST' | 'GET' | 'PATCH' | 'PUT' | 'DELETE';\n  url?: string;\n  body?: any;\n  options?: RequestInit;\n}\n\ninterface FetchError extends Error {\n  status?: number;\n  response?: any;\n}\n\nconst useFetch = <T>({ method = 'GET', url, body, options }: IProps) => {\n  const [loading, setLoading] = useState(false);\n  const [data, setData] = useState<T | null>(null);\n  const [error, setError] = useState<FetchError | null>(null);\n\n  const [, setIsLogged] = useLocalStorage(\n    process.env.REACT_APP_LOGGED_KEY || 'APP_LOGGED',\n    false\n  );\n  const navigate = useNavigate();\n  const abortController = useRef<AbortController | null>(null);\n\n  const doFetch = useCallback(\n    async ({\n      url: fetchUrl,\n      body: fetchBody,\n      method: fetchMethod = method,\n    }: {\n      url: string;\n      body?: any;\n      method?: 'POST' | 'GET' | 'PATCH' | 'PUT' | 'DELETE';\n    }) => {\n      setLoading(true);\n      setError(null);\n\n      // cancela requisição anterior se ainda estiver ativa\n      if (abortController.current) {\n        abortController.current.abort();\n      }\n      abortController.current = new AbortController();\n\n      // Headers do serviço (ex: Authorization)\n      const baseOptions = getHeaderOptions() || {};\n\n      // Garantir merge correto de headers (não sobrescrever acidentalmente)\n      const mergedHeaders = {\n        ...(baseOptions as any).headers,\n        ...(options && (options as any).headers),\n      };\n\n      // Montar fetch options\n      const fetchOptions: RequestInit = {\n        method: fetchMethod,\n        headers: mergedHeaders,\n        signal: abortController.current.signal,\n        // permite controlar envio de cookies, útil se backend usa sessão\n        credentials:\n          (options && (options as any).credentials) ||\n          (baseOptions as any).credentials ||\n          'same-origin',\n        ...options,\n      };\n\n      if (fetchBody) {\n        // se não existir Content-Type, definir application/json\n        if (!('Content-Type' in (fetchOptions.headers || {}))) {\n          (fetchOptions.headers as any) = {\n            ...(fetchOptions.headers as any),\n            'Content-Type': 'application/json',\n          };\n        }\n        fetchOptions.body = JSON.stringify(fetchBody);\n      }\n\n      // DEBUG: inspecionar URL e headers no console\n      // Remover/condicionar em produção\n      // eslint-disable-next-line no-console\n      // console.log('doFetch ->', fetchUrl, fetchOptions);\n\n      try {\n        const response = await fetch(fetchUrl, fetchOptions);\n\n        const text = await response.text();\n        // Tentar parsear JSON se houver conteúdo\n        let parsed;\n        try {\n          parsed = text ? JSON.parse(text) : null;\n        } catch {\n          parsed = text;\n        }\n\n        if (!response.ok) {\n          const fetchError: FetchError = new Error(\n            (parsed && parsed.message) || response.statusText || 'Erro na requisição'\n          );\n          fetchError.status = response.status;\n          fetchError.response = parsed;\n          throw fetchError;\n        }\n\n        // normaliza resposta no formato `{ data: ... }`\n        const normalized = parsed && (parsed.data || parsed);\n\n        setData(normalized);\n        return normalized as T;\n      } catch (err: any) {\n        if (err.name !== 'AbortError') {\n          setError(err);\n\n          // ações automáticas de acordo com status\n          if (err.status === 401) {\n            setIsLogged(false);\n          }\n          if (err.status === 403) {\n            navigate('/');\n          }\n        }\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [method, navigate, options, setIsLogged]\n  );\n\n  // efeito inicial caso `url` seja passado direto\n  useEffect(() => {\n    if (url) {\n      doFetch({ url, body, method });\n    }\n    return () => {\n      if (abortController.current) {\n        abortController.current.abort();\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [url, JSON.stringify(body), method]);\n\n  return { doFetch, data, error, loading };\n};\n\nexport default useFetch;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}