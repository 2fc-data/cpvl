{"ast":null,"code":"// import { useEffect, useRef, useState, useCallback } from 'react';\n// import { useLocalStorage } from 'usehooks-ts';\n// import { getHeaderOptions } from '../services';\n// import { useNavigate } from 'react-router-dom';\n\n// interface IProps {\n//   method?: 'POST' | 'GET' | 'PATCH' | 'PUT' | 'DELETE';\n//   url?: string;\n//   body?: any;\n//   options?: RequestInit;\n// }\n\n// interface FetchError extends Error {\n//   status?: number;\n//   response?: any;\n// }\n\n// const useFetch = <T>({ method = 'GET', url, body, options }: IProps) => {\n//   const [loading, setLoading] = useState(false);\n//   const [data, setData] = useState<T | null>(null);\n//   const [error, setError] = useState<FetchError | null>(null);\n\n//   const [, setIsLogged] = useLocalStorage(\n//     process.env.REACT_APP_LOGGED_KEY || 'APP_LOGGED',\n//     false\n//   );\n//   const navigate = useNavigate();\n//   const abortController = useRef<AbortController | null>(null);\n\n//   const doFetch = useCallback(\n//     async ({\n//       url: fetchUrl,\n//       body: fetchBody,\n//       method: fetchMethod = method\n//     }: {\n//       url: string;\n//       body?: any;\n//       method?: 'POST' | 'GET' | 'PATCH' | 'PUT' | 'DELETE';\n//     }) => {\n//       setLoading(true);\n//       setError(null);\n\n//       // cancela requisição anterior se ainda estiver ativa\n//       if (abortController.current) {\n//         abortController.current.abort();\n//       }\n//       abortController.current = new AbortController();\n\n//       try {\n//         const response = await fetch(fetchUrl, {\n//           method: fetchMethod,\n//           ...(fetchBody && { body: JSON.stringify(fetchBody) }),\n//           ...getHeaderOptions(),\n//           ...options,\n//           signal: abortController.current.signal\n//         });        \n\n//         if (!response.ok) {\n//           const fetchError: FetchError = new Error(\n//             response.statusText || 'Erro na requisição'\n//           );\n//           fetchError.status = response.status;\n//           throw fetchError;\n//         }\n\n//         const json = await response.json();\n\n//         // normaliza resposta no formato `{ data: ... }`\n//         const normalized = json!.data || json;\n\n//         setData(normalized);\n//         return normalized as T;\n//       } catch (err: any) {\n//         if (err.name !== 'AbortError') {\n//           setError(err);\n\n//           if (err.status === 401) {\n//             setIsLogged(false);\n//           }\n//           if (err.status === 403) {\n//             navigate('/');\n//           }\n//         }\n//       } finally {\n//         setLoading(false);\n//       }\n//     },\n//     [method, navigate, options, setIsLogged]\n//   );\n\n//   // efeito inicial caso `url` seja passado direto\n//   useEffect(() => {\n//     if (url) {\n//       doFetch({ url, body, method });\n//     }\n//     return () => {\n//       if (abortController.current) {\n//         abortController.current.abort();\n//       }\n//     };\n//     // eslint-disable-next-line react-hooks/exhaustive-deps\n//   }, [url, body, method]);\n\n//   return { doFetch, data, error, loading };\n// };\n\n// export default useFetch;","map":{"version":3,"names":[],"sources":["/home/fernando/Documents/develop/www/cpvl/v4_cpvl_2025/cpvl-spa/src/hooks/useFetch.ts"],"sourcesContent":["// import { useEffect, useRef, useState, useCallback } from 'react';\n// import { useLocalStorage } from 'usehooks-ts';\n// import { getHeaderOptions } from '../services';\n// import { useNavigate } from 'react-router-dom';\n\n// interface IProps {\n//   method?: 'POST' | 'GET' | 'PATCH' | 'PUT' | 'DELETE';\n//   url?: string;\n//   body?: any;\n//   options?: RequestInit;\n// }\n\n// interface FetchError extends Error {\n//   status?: number;\n//   response?: any;\n// }\n\n// const useFetch = <T>({ method = 'GET', url, body, options }: IProps) => {\n//   const [loading, setLoading] = useState(false);\n//   const [data, setData] = useState<T | null>(null);\n//   const [error, setError] = useState<FetchError | null>(null);\n\n//   const [, setIsLogged] = useLocalStorage(\n//     process.env.REACT_APP_LOGGED_KEY || 'APP_LOGGED',\n//     false\n//   );\n//   const navigate = useNavigate();\n//   const abortController = useRef<AbortController | null>(null);\n\n//   const doFetch = useCallback(\n//     async ({\n//       url: fetchUrl,\n//       body: fetchBody,\n//       method: fetchMethod = method\n//     }: {\n//       url: string;\n//       body?: any;\n//       method?: 'POST' | 'GET' | 'PATCH' | 'PUT' | 'DELETE';\n//     }) => {\n//       setLoading(true);\n//       setError(null);\n\n//       // cancela requisição anterior se ainda estiver ativa\n//       if (abortController.current) {\n//         abortController.current.abort();\n//       }\n//       abortController.current = new AbortController();\n\n//       try {\n//         const response = await fetch(fetchUrl, {\n//           method: fetchMethod,\n//           ...(fetchBody && { body: JSON.stringify(fetchBody) }),\n//           ...getHeaderOptions(),\n//           ...options,\n//           signal: abortController.current.signal\n//         });        \n\n//         if (!response.ok) {\n//           const fetchError: FetchError = new Error(\n//             response.statusText || 'Erro na requisição'\n//           );\n//           fetchError.status = response.status;\n//           throw fetchError;\n//         }\n\n//         const json = await response.json();\n\n//         // normaliza resposta no formato `{ data: ... }`\n//         const normalized = json!.data || json;\n\n//         setData(normalized);\n//         return normalized as T;\n//       } catch (err: any) {\n//         if (err.name !== 'AbortError') {\n//           setError(err);\n\n//           if (err.status === 401) {\n//             setIsLogged(false);\n//           }\n//           if (err.status === 403) {\n//             navigate('/');\n//           }\n//         }\n//       } finally {\n//         setLoading(false);\n//       }\n//     },\n//     [method, navigate, options, setIsLogged]\n//   );\n\n//   // efeito inicial caso `url` seja passado direto\n//   useEffect(() => {\n//     if (url) {\n//       doFetch({ url, body, method });\n//     }\n//     return () => {\n//       if (abortController.current) {\n//         abortController.current.abort();\n//       }\n//     };\n//     // eslint-disable-next-line react-hooks/exhaustive-deps\n//   }, [url, body, method]);\n\n//   return { doFetch, data, error, loading };\n// };\n\n// export default useFetch;\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}