{"ast":null,"code":"// import { useEffect, useRef, useState, useCallback } from 'react';\n// import { useLocalStorage } from 'usehooks-ts';\n// import { getHeaderOptions } from '../services';\n// import { useNavigate } from 'react-router-dom';\n\n// interface IProps {\n//   method?: 'POST' | 'GET' | 'PATCH' | 'PUT' | 'DELETE';\n//   url?: string;\n//   body?: any;\n//   options?: RequestInit;\n// }\n\n// interface FetchError extends Error {\n//   status?: number;\n//   response?: any;\n// }\n\n// const useFetch = <T>({ method = 'GET', url, body, options }: IProps) => {\n//   const [loading, setLoading] = useState(false);\n//   const [data, setData] = useState<T | null>(null);\n//   const [error, setError] = useState<FetchError | null>(null);\n\n//   const [, setIsLogged] = useLocalStorage(\n//     process.env.REACT_APP_LOGGED_KEY || 'APP_LOGGED',\n//     false\n//   );\n//   const navigate = useNavigate();\n//   const abortController = useRef<AbortController | null>(null);\n\n//   const doFetch = useCallback(\n//     async ({\n//       url: fetchUrl,\n//       body: fetchBody,\n//       method: fetchMethod = method\n//     }: {\n//       url: string;\n//       body?: any;\n//       method?: 'POST' | 'GET' | 'PATCH' | 'PUT' | 'DELETE';\n//     }) => {\n//       setLoading(true);\n//       setError(null);\n\n//       // cancela requisição anterior se ainda estiver ativa\n//       if (abortController.current) {\n//         abortController.current.abort();\n//       }\n//       abortController.current = new AbortController();\n\n//       try {\n//         const response = await fetch(fetchUrl, {\n//           method: fetchMethod,\n//           ...(fetchBody && { body: JSON.stringify(fetchBody) }),\n//           ...getHeaderOptions(),\n//           ...options,\n//           signal: abortController.current.signal\n//         });\n\n//         if (!response.ok) {\n//           const fetchError: FetchError = new Error(\n//             response.statusText || 'Erro na requisição'\n//           );\n//           fetchError.status = response.status;\n//           throw fetchError;\n//         }\n\n//         const json = await response.json();\n\n//         // normaliza resposta no formato `{ data: ... }`\n//         const normalized = json!.data || json;\n\n//         setData(normalized);\n//         return normalized as T;\n//       } catch (err: any) {\n//         if (err.name !== 'AbortError') {\n//           setError(err);\n\n//           if (err.status === 401) {\n//             setIsLogged(false);\n//           }\n//           if (err.status === 403) {\n//             navigate('/');\n//           }\n//         }\n//       } finally {\n//         setLoading(false);\n//       }\n//     },\n//     [method, navigate, options, setIsLogged]\n//   );\n\n//   // efeito inicial caso `url` seja passado direto\n//   useEffect(() => {\n//     if (url) {\n//       doFetch({ url, body, method });\n//     }\n//     return () => {\n//       if (abortController.current) {\n//         abortController.current.abort();\n//       }\n//     };\n//     // eslint-disable-next-line react-hooks/exhaustive-deps\n//   }, [url, body, method]);\n\n//   return { doFetch, data, error, loading };\n// };\n\n// export default useFetch;\n\n// useFetch.tsx (versão atualizada)\n// import { useEffect, useRef, useState, useCallback } from 'react';\n// import { useLocalStorage } from 'usehooks-ts';\n// import { getHeaderOptions } from '../services';\n// import { useNavigate } from 'react-router-dom';\n\n// interface IProps {\n//   method?: 'POST' | 'GET' | 'PATCH' | 'PUT' | 'DELETE';\n//   url?: string;\n//   body?: any;\n//   options?: RequestInit;\n// }\n\n// interface FetchError extends Error {\n//   status?: number;\n//   response?: any;\n// }\n\n// const useFetch = <T>({ method = 'GET', url, body, options }: IProps) => {\n//   const [loading, setLoading] = useState(false);\n//   const [data, setData] = useState<T | null>(null);\n//   const [error, setError] = useState<FetchError | null>(null);\n\n//   const [, setIsLogged] = useLocalStorage(\n//     process.env.REACT_APP_LOGGED_KEY || 'APP_LOGGED',\n//     false\n//   );\n//   const navigate = useNavigate();\n//   const abortController = useRef<AbortController | null>(null);\n\n//   const doFetch = useCallback(\n//     async ({\n//       url: fetchUrl,\n//       body: fetchBody,\n//       method: fetchMethod = method\n//     }: {\n//       url: string;\n//       body?: any;\n//       method?: 'POST' | 'GET' | 'PATCH' | 'PUT' | 'DELETE';\n//     }) => {\n//       setLoading(true);\n//       setError(null);\n\n//       // cancela requisição anterior se ainda estiver ativa\n//       if (abortController.current) {\n//         abortController.current.abort();\n//       }\n//       abortController.current = new AbortController();\n\n//       // Headers do serviço (ex: Authorization)\n//       const baseOptions = getHeaderOptions() || {};\n\n//       // Garantir merge correto de headers (não sobrescrever acidentalmente)\n//       const mergedHeaders = {\n//         ...(baseOptions as any).headers,\n//         ...(options && (options as any).headers)\n//       };\n\n//       // Montar fetch options\n//       const fetchOptions: RequestInit = {\n//         method: fetchMethod,\n//         headers: mergedHeaders,\n//         signal: abortController.current.signal,\n//         // permite controlar envio de cookies, útil se backend usa sessão\n//         credentials:\n//           (options && (options as any).credentials) ||\n//           (baseOptions as any).credentials ||\n//           'same-origin',\n//         ...options\n//       };\n\n//       if (fetchBody) {\n//         // se não existir Content-Type, definir application/json\n//         if (!('Content-Type' in (fetchOptions.headers || {}))) {\n//           (fetchOptions.headers as any) = {\n//             ...(fetchOptions.headers as any),\n//             'Content-Type': 'application/json'\n//           };\n//         }\n//         fetchOptions.body = JSON.stringify(fetchBody);\n//       }\n\n//       // DEBUG: inspecionar URL e headers no console\n//       // Remover/condicionar em produção\n//       // eslint-disable-next-line no-console\n//       // console.log('doFetch ->', fetchUrl, fetchOptions);\n\n//       try {\n//         const response = await fetch(fetchUrl, fetchOptions);\n\n//         const text = await response.text();\n//         // Tentar parsear JSON se houver conteúdo\n//         let parsed;\n//         try {\n//           parsed = text ? JSON.parse(text) : null;\n//         } catch {\n//           parsed = text;\n//         }\n\n//         if (!response.ok) {\n//           const fetchError: FetchError = new Error(\n//             (parsed && parsed.message) ||\n//               response.statusText ||\n//               'Erro na requisição'\n//           );\n//           fetchError.status = response.status;\n//           fetchError.response = parsed;\n//           throw fetchError;\n//         }\n\n//         // normaliza resposta no formato `{ data: ... }`\n//         const normalized = parsed && (parsed.data || parsed);\n\n//         setData(normalized);\n//         return normalized as T;\n//       } catch (err: any) {\n//         if (err.name !== 'AbortError') {\n//           setError(err);\n\n//           // ações automáticas de acordo com status\n//           if (err.status === 401) {\n//             setIsLogged(false);\n//           }\n//           if (err.status === 403) {\n//             navigate('/');\n//           }\n//         }\n//         throw err;\n//       } finally {\n//         setLoading(false);\n//       }\n//     },\n//     [method, navigate, options, setIsLogged]\n//   );\n\n//   // efeito inicial caso `url` seja passado direto\n//   useEffect(() => {\n//     if (url) {\n//       doFetch({ url, body, method });\n//     }\n//     return () => {\n//       if (abortController.current) {\n//         abortController.current.abort();\n//       }\n//     };\n//     // eslint-disable-next-line react-hooks/exhaustive-deps\n//   }, [url, JSON.stringify(body), method]);\n\n//   return { doFetch, data, error, loading };\n// };\n\n// export default useFetch;","map":{"version":3,"names":[],"sources":["/home/fernando/Documents/develop/www/cpvl/v4_cpvl_2025/cpvl-spa/src/hooks/useFetch.ts"],"sourcesContent":["// import { useEffect, useRef, useState, useCallback } from 'react';\n// import { useLocalStorage } from 'usehooks-ts';\n// import { getHeaderOptions } from '../services';\n// import { useNavigate } from 'react-router-dom';\n\n// interface IProps {\n//   method?: 'POST' | 'GET' | 'PATCH' | 'PUT' | 'DELETE';\n//   url?: string;\n//   body?: any;\n//   options?: RequestInit;\n// }\n\n// interface FetchError extends Error {\n//   status?: number;\n//   response?: any;\n// }\n\n// const useFetch = <T>({ method = 'GET', url, body, options }: IProps) => {\n//   const [loading, setLoading] = useState(false);\n//   const [data, setData] = useState<T | null>(null);\n//   const [error, setError] = useState<FetchError | null>(null);\n\n//   const [, setIsLogged] = useLocalStorage(\n//     process.env.REACT_APP_LOGGED_KEY || 'APP_LOGGED',\n//     false\n//   );\n//   const navigate = useNavigate();\n//   const abortController = useRef<AbortController | null>(null);\n\n//   const doFetch = useCallback(\n//     async ({\n//       url: fetchUrl,\n//       body: fetchBody,\n//       method: fetchMethod = method\n//     }: {\n//       url: string;\n//       body?: any;\n//       method?: 'POST' | 'GET' | 'PATCH' | 'PUT' | 'DELETE';\n//     }) => {\n//       setLoading(true);\n//       setError(null);\n\n//       // cancela requisição anterior se ainda estiver ativa\n//       if (abortController.current) {\n//         abortController.current.abort();\n//       }\n//       abortController.current = new AbortController();\n\n//       try {\n//         const response = await fetch(fetchUrl, {\n//           method: fetchMethod,\n//           ...(fetchBody && { body: JSON.stringify(fetchBody) }),\n//           ...getHeaderOptions(),\n//           ...options,\n//           signal: abortController.current.signal\n//         });\n\n//         if (!response.ok) {\n//           const fetchError: FetchError = new Error(\n//             response.statusText || 'Erro na requisição'\n//           );\n//           fetchError.status = response.status;\n//           throw fetchError;\n//         }\n\n//         const json = await response.json();\n\n//         // normaliza resposta no formato `{ data: ... }`\n//         const normalized = json!.data || json;\n\n//         setData(normalized);\n//         return normalized as T;\n//       } catch (err: any) {\n//         if (err.name !== 'AbortError') {\n//           setError(err);\n\n//           if (err.status === 401) {\n//             setIsLogged(false);\n//           }\n//           if (err.status === 403) {\n//             navigate('/');\n//           }\n//         }\n//       } finally {\n//         setLoading(false);\n//       }\n//     },\n//     [method, navigate, options, setIsLogged]\n//   );\n\n//   // efeito inicial caso `url` seja passado direto\n//   useEffect(() => {\n//     if (url) {\n//       doFetch({ url, body, method });\n//     }\n//     return () => {\n//       if (abortController.current) {\n//         abortController.current.abort();\n//       }\n//     };\n//     // eslint-disable-next-line react-hooks/exhaustive-deps\n//   }, [url, body, method]);\n\n//   return { doFetch, data, error, loading };\n// };\n\n// export default useFetch;\n\n// useFetch.tsx (versão atualizada)\n// import { useEffect, useRef, useState, useCallback } from 'react';\n// import { useLocalStorage } from 'usehooks-ts';\n// import { getHeaderOptions } from '../services';\n// import { useNavigate } from 'react-router-dom';\n\n// interface IProps {\n//   method?: 'POST' | 'GET' | 'PATCH' | 'PUT' | 'DELETE';\n//   url?: string;\n//   body?: any;\n//   options?: RequestInit;\n// }\n\n// interface FetchError extends Error {\n//   status?: number;\n//   response?: any;\n// }\n\n// const useFetch = <T>({ method = 'GET', url, body, options }: IProps) => {\n//   const [loading, setLoading] = useState(false);\n//   const [data, setData] = useState<T | null>(null);\n//   const [error, setError] = useState<FetchError | null>(null);\n\n//   const [, setIsLogged] = useLocalStorage(\n//     process.env.REACT_APP_LOGGED_KEY || 'APP_LOGGED',\n//     false\n//   );\n//   const navigate = useNavigate();\n//   const abortController = useRef<AbortController | null>(null);\n\n//   const doFetch = useCallback(\n//     async ({\n//       url: fetchUrl,\n//       body: fetchBody,\n//       method: fetchMethod = method\n//     }: {\n//       url: string;\n//       body?: any;\n//       method?: 'POST' | 'GET' | 'PATCH' | 'PUT' | 'DELETE';\n//     }) => {\n//       setLoading(true);\n//       setError(null);\n\n//       // cancela requisição anterior se ainda estiver ativa\n//       if (abortController.current) {\n//         abortController.current.abort();\n//       }\n//       abortController.current = new AbortController();\n\n//       // Headers do serviço (ex: Authorization)\n//       const baseOptions = getHeaderOptions() || {};\n\n//       // Garantir merge correto de headers (não sobrescrever acidentalmente)\n//       const mergedHeaders = {\n//         ...(baseOptions as any).headers,\n//         ...(options && (options as any).headers)\n//       };\n\n//       // Montar fetch options\n//       const fetchOptions: RequestInit = {\n//         method: fetchMethod,\n//         headers: mergedHeaders,\n//         signal: abortController.current.signal,\n//         // permite controlar envio de cookies, útil se backend usa sessão\n//         credentials:\n//           (options && (options as any).credentials) ||\n//           (baseOptions as any).credentials ||\n//           'same-origin',\n//         ...options\n//       };\n\n//       if (fetchBody) {\n//         // se não existir Content-Type, definir application/json\n//         if (!('Content-Type' in (fetchOptions.headers || {}))) {\n//           (fetchOptions.headers as any) = {\n//             ...(fetchOptions.headers as any),\n//             'Content-Type': 'application/json'\n//           };\n//         }\n//         fetchOptions.body = JSON.stringify(fetchBody);\n//       }\n\n//       // DEBUG: inspecionar URL e headers no console\n//       // Remover/condicionar em produção\n//       // eslint-disable-next-line no-console\n//       // console.log('doFetch ->', fetchUrl, fetchOptions);\n\n//       try {\n//         const response = await fetch(fetchUrl, fetchOptions);\n\n//         const text = await response.text();\n//         // Tentar parsear JSON se houver conteúdo\n//         let parsed;\n//         try {\n//           parsed = text ? JSON.parse(text) : null;\n//         } catch {\n//           parsed = text;\n//         }\n\n//         if (!response.ok) {\n//           const fetchError: FetchError = new Error(\n//             (parsed && parsed.message) ||\n//               response.statusText ||\n//               'Erro na requisição'\n//           );\n//           fetchError.status = response.status;\n//           fetchError.response = parsed;\n//           throw fetchError;\n//         }\n\n//         // normaliza resposta no formato `{ data: ... }`\n//         const normalized = parsed && (parsed.data || parsed);\n\n//         setData(normalized);\n//         return normalized as T;\n//       } catch (err: any) {\n//         if (err.name !== 'AbortError') {\n//           setError(err);\n\n//           // ações automáticas de acordo com status\n//           if (err.status === 401) {\n//             setIsLogged(false);\n//           }\n//           if (err.status === 403) {\n//             navigate('/');\n//           }\n//         }\n//         throw err;\n//       } finally {\n//         setLoading(false);\n//       }\n//     },\n//     [method, navigate, options, setIsLogged]\n//   );\n\n//   // efeito inicial caso `url` seja passado direto\n//   useEffect(() => {\n//     if (url) {\n//       doFetch({ url, body, method });\n//     }\n//     return () => {\n//       if (abortController.current) {\n//         abortController.current.abort();\n//       }\n//     };\n//     // eslint-disable-next-line react-hooks/exhaustive-deps\n//   }, [url, JSON.stringify(body), method]);\n\n//   return { doFetch, data, error, loading };\n// };\n\n// export default useFetch;\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}